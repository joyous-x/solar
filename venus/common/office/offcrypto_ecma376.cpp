#include <cassert>
#include "offcrypto.h"
#include "offcrypto_assist.h"
#include "../3rds/sha1.h"
#include "../3rds/aes.h"
#include "../3rds/base64.h"
#include "../utils/hash.h"
#include "../utils/utils.h"
#include "../utils/scope_guard.h"

int decrypt_aes(const char* mode, const uint8_t* key, uint32_t key_bits, const uint8_t* iv, uint32_t iv_size, uint8_t* buffer, uint32_t size, uint8_t* out, ifile* file = 0, uint32_t filepos = 0) {
    if (nullptr == mode || (nullptr == out  && file == nullptr) || key_bits % 8 != 0) {
        return BQ::INVALID_ARG;
    }

    unsigned char* rst = nullptr;
    uint8_t* buf_padded = nullptr;
    uint32_t aligned_size = size;

    if (size % AES_BLOCK_SIZE != 0) {
        aligned_size = (size / AES_BLOCK_SIZE + 1) * AES_BLOCK_SIZE;
        buf_padded = (uint8_t*)malloc(aligned_size);
        if (buf_padded == nullptr) {
            return BQ::ERR_MALLOC;
        }
        memset(buf_padded, 0, aligned_size);
        memcpy(buf_padded, buffer, size);
    }
    ON_SCOPE_EXIT([&]() { if (buf_padded) free(buf_padded); buf_padded = nullptr; });

    AES aes(key_bits);
    if (0 == strcmp(mode, "ecb")) {
        rst = aes.DecryptECB(buf_padded ? buf_padded : buffer, aligned_size, (unsigned char*)key);
    }
    else if (0 == strcmp(mode, "cbc")) {
        assert(iv_size >= 0x10);
        rst = aes.DecryptCBC(buf_padded ? buf_padded : buffer, aligned_size, (unsigned char*)key, (unsigned char*)iv);
    }
    else if (0 == strcmp(mode, "cfb")) {
        assert(iv_size >= 0x10);
        rst = aes.DecryptCFB(buf_padded ? buf_padded : buffer, aligned_size, (unsigned char*)key, (unsigned char*)iv);
    }

    if (rst == nullptr) {
        return BQ::ERR;
    }
    
    if (file) {
        file->write(filepos, rst, size);
    }

    if (out) {
        memcpy(out, rst, size);
    }
    delete[] rst;

    return BQ::OK;
}

/*
* ECMA-376 Document Encryption Key Generation (Standard Encryption)
*   The encryption key for ECMA-376 document encryption MUST be generated by using the
*   following method, which is derived from PKCS #5: Password - Based Cryptography Version 2.0[RFC2898]
*  
*   Hash algorithm MUST be Sha1
*/
int ecma376_std_encryption_key(encryption_info_std_t* encrypt, const char16_t* passwd, uint8_t* out, uint32_t& out_size) {
    if (encrypt == nullptr || nullptr == passwd) {
        return BQ::INVALID_ARG;
    }

    const uint32_t block_num = 0x0;
    const uint32_t iteration = 50000;
    const uint32_t cbHash = 20;
    uint8_t hash[cbHash] = {0};
    uint8_t x1_x2[cbHash * 2] = { 0 };

    assert(encrypt->verifier.salt_size == 0x10);
    sha1 sha1_calc;
    sha1_calc.add(encrypt->verifier.salt, encrypt->verifier.salt_size).add(passwd, ucs::len<char16_t>(passwd) * sizeof(char16_t)).finalize();
    memcpy(hash, sha1_calc.digest(), sizeof(hash));

    for (uint32_t i = 0; i < iteration; i++) {
        memcpy(hash, sha1().add(&i, sizeof(uint32_t)).add(hash, sizeof(hash)).finalize().digest(), sizeof(hash));
    }

    sha1 sha1_final;
    sha1_final.add(hash, sizeof(hash)).add(&block_num, sizeof(uint32_t)).finalize();
    memcpy(hash, sha1_final.digest(), sizeof(hash));

    uint32_t key_len = encrypt->header.key_size / 8;
    assert(key_len  <= 40);
    uint8_t buffer[64] = { 0 };

    do {
        memset(buffer, 0x36, sizeof(buffer));
        for (uint32_t i = 0; i < cbHash; i++) {
            buffer[i] ^= hash[i];
        }
        memcpy(x1_x2, sha1().add(buffer, sizeof(buffer)).finalize().digest(), cbHash);
    } while (false);
    
    do {
        memset(buffer, 0x5C, sizeof(buffer));
        for (uint32_t i = 0; i < cbHash; i++) {
            buffer[i] ^= hash[i];
        }
        memcpy(x1_x2 + cbHash, sha1().add(buffer, sizeof(buffer)).finalize().digest(), cbHash);
    } while (false);

    if (key_len > cbHash * 2 || out_size < key_len) {
        return BQ::ERR;
    }

    memcpy(out, x1_x2, key_len);
    out_size = key_len;

    return 0;

}

/*
* The encryption algorithm MUST use ECB mode
*/
int ecma376_std_passwd_verify(encryption_info_std_t* encrypt, const char16_t* passwd) {
    if (encrypt == nullptr) {
        return BQ::INVALID_ARG;
    }
    
    std::string encrypt_algorithm = "";
    if (0 == (encrypt->header.flags & 0x20)) {
        if (encrypt->header.algid == 0 || encrypt->header.algid == 0x6801) {
            encrypt_algorithm = "RC4";
        }
    }
    else {
        if (encrypt->header.algid == 0 || encrypt->header.algid == 0x660E) {
            encrypt_algorithm = "AES 128";
        }
        else if (encrypt->header.algid == 0x660F) {
            encrypt_algorithm = "AES 192";
        }
        else if (encrypt->header.algid == 0x6610) {
            encrypt_algorithm = "AES 256";
        }
    }

    assert(false == encrypt_algorithm.empty());
    /* sha1 */
    assert(encrypt->header.algid_hash == 0 || encrypt->header.algid_hash == 0x8004);

    /* now, we only process the aes algorithm */
    if (encrypt->header.provider_type != 0x00000018) {
        return BQ::NOT_IMPLEMENT;
    }

    uint32_t encrypt_key_size = encrypt->header.key_size / 8;
    uint8_t* encrypt_key = (uint8_t*)malloc(encrypt_key_size);
    if (encrypt_key == nullptr) {
        return BQ::ERR_MALLOC;
    }
    ON_SCOPE_EXIT([&]() {if (encrypt_key) free(encrypt_key); });
    memset(encrypt_key, 0, encrypt_key_size);

    int nret = ecma376_std_encryption_key(encrypt, passwd, encrypt_key, encrypt_key_size);
    if (nret != BQ::OK) {
        return nret;
    }

    uint8_t verifier[16] = { 0 };
    nret = decrypt_aes("ecb", encrypt_key, encrypt->header.key_size, 0, 0, encrypt->verifier.encrypted_verifier, sizeof(encrypt->verifier.encrypted_verifier), verifier);
    if (nret != BQ::OK) {
        return nret;
    }

    uint8_t verifier_hash[32] = { 0 };
    nret = decrypt_aes("ecb", encrypt_key, encrypt->header.key_size, 0, 0, encrypt->verifier.encrypted_verifier_hash, sizeof(verifier_hash), verifier_hash);
    if (nret != BQ::OK) {
        return nret;
    }
    assert(encrypt->verifier.verifier_hash_size == 20);

    uint8_t verifier_sha1[20] = { 0 };
    memcpy(verifier_sha1, sha1().add(verifier, sizeof(verifier)).finalize().digest(), sizeof(verifier_sha1));

    if (0 != memcmp(verifier_hash, verifier_sha1, sizeof(verifier_sha1))) {
        nret = BQ::ERR_PASSWD;
    }
    else {
        nret = BQ::OK;
    }

    return nret;
}

int ecma376_std_decrypt(encryption_info_std_t* encrypt, const char16_t* passwd, uint8_t* data, uint32_t size, ifile* out) {
    const uint32_t stream_size_bytes = 8;
    if (encrypt == nullptr || data == nullptr || size < stream_size_bytes || nullptr == out) {
        return BQ::INVALID_ARG;
    }

    uint32_t encrypt_key_bytes = encrypt->header.key_size / 8;
    uint8_t* encrypt_key = (uint8_t*)malloc(encrypt_key_bytes);
    if (encrypt_key == nullptr) {
        return BQ::ERR_MALLOC;
    }
    ON_SCOPE_EXIT([&]() {if (encrypt_key) free(encrypt_key); });
    memset(encrypt_key, 0, encrypt_key_bytes);

    int nret = ecma376_std_encryption_key(encrypt, passwd, encrypt_key, encrypt_key_bytes);
    if (nret != BQ::OK) {
        return nret;
    }

    nret = decrypt_aes("ecb", encrypt_key, encrypt->header.key_size, 0, 0, data + stream_size_bytes, size - stream_size_bytes, 0, out);
    if (nret != BQ::OK) {
        nret = BQ::ERR_DECRYPT;
    }

    return nret;
}

int ecma376_agile_encryption_key__final(encryption_info_agile_t* encrypt, const uint8_t* blockey, uint32_t blocksize, uint8_t* hash, uint32_t& size) {
    if (encrypt == nullptr || hash == nullptr || size < encrypt->encryptor.keybits / 8) {
        return BQ::INVALID_ARG;
    }
    
    uint32_t key_len = encrypt->encryptor.keybits / 8;
    uint32_t cbhash = encrypt->encryptor.hashsize;
    
    if (blockey && blocksize > 0) {
        Hash hfinal(encrypt->encryptor.hash_algor);
        memcpy(hash, hfinal.add(hash, size).add(blockey, blocksize).finalize().bytes(), std::min(key_len, cbhash));
    }
    size = key_len;

    return BQ::OK;
}

int ecma376_agile_encryption_key__iteration(encryption_info_agile_t* encrypt, const char16_t* passwd, uint8_t* hash, uint32_t& size) {
    if (encrypt == nullptr || nullptr == passwd || hash == nullptr || size == 0) {
        return BQ::INVALID_ARG;
    }

    uint32_t cbHash = 0;
    Hash(encrypt->encryptor.hash_algor).bytes(&cbHash);
    if (cbHash == 0) {
        return BQ::INVALID_ARG;
    }
    assert(cbHash == encrypt->encryptor.hashsize);
    if (size < cbHash) {
        return BQ::INVALID_ARG;
    }
    
    Hash h0(encrypt->encryptor.hash_algor);
    h0.add(encrypt->encryptor.salt, encrypt->encryptor.saltsize).add((const uint8_t*)passwd, ucs::len<char16_t>(passwd) * sizeof(char16_t)).finalize();
    memcpy(hash, h0.bytes(), cbHash);

    for (uint32_t i = 0; i < encrypt->encryptor.spin_cnt; i++) {
        Hash hiter(encrypt->encryptor.hash_algor);
        auto bytes = hiter.add((const uint8_t*)&i, sizeof(uint32_t)).add(hash, cbHash).finalize().bytes();
        memcpy(hash, bytes, cbHash);
    }

    size = cbHash;
    return BQ::OK;
}

int ecma376_agile_integrity_verify(encryption_info_agile_t* encrypt, const uint8_t* data, uint32_t size, const uint8_t* key, uint32_t key_size) {
    if (encrypt == nullptr || nullptr == data || key == nullptr 
        || encrypt->integrity.encrypted_hmac_key == nullptr
        || encrypt->integrity.encrypted_hmac_val == nullptr) {
        return BQ::INVALID_ARG;
    }

    auto salt = encrypt->keydata.salt;
    auto salt_size = encrypt->keydata.saltsize;
    auto hash_algo = encrypt->keydata.cipher_algor;
    auto blocksize = encrypt->keydata.blocksize;
    const char* mode = nullptr;
    if (0 == strcmp(encrypt->keydata.cipher_chain, "ChainingModeCFB")) {
        mode = "cfb"; // Cipher feedback chaining(CFB), with an 8-bit window
    }
    else if (0 == strcmp(encrypt->keydata.cipher_chain, "ChainingModeCBC")) {
        mode = "cbc";
    }

    uint8_t blockey_k[] = { 0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6 };
    uint8_t blockey_v[] = { 0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33 };

    Hash hash_k(hash_algo);
    hash_k.add(salt, salt_size).add(blockey_k, sizeof(blockey_k)).finalize();
    Hash hash_v(hash_algo);
    hash_v.add(salt, salt_size).add(blockey_v, sizeof(blockey_v)).finalize();

    auto encrypted_key_b64 = (const char*)encrypt->integrity.encrypted_hmac_key;
    uint32_t encrypted_key_size = 0;
    uint8_t* encrypted_key = base64_decode((const unsigned char*)encrypted_key_b64, strlen(encrypted_key_b64), (size_t*)&encrypted_key_size);
    ON_SCOPE_EXIT([&]() { if (encrypted_key) free(encrypted_key); encrypted_key = nullptr; });

    auto encrypted_val_b64 = (const char*)encrypt->integrity.encrypted_hmac_val;
    uint32_t encrypted_val_size = 0;
    uint8_t* encrypted_val = base64_decode((const unsigned char*)encrypted_val_b64, strlen(encrypted_val_b64), (size_t*)&encrypted_val_size);
    ON_SCOPE_EXIT([&]() { if (encrypted_val) free(encrypted_val); encrypted_val = nullptr; });

    uint8_t* decrypted_key = (uint8_t*)malloc(encrypted_key_size);
    if (decrypted_key == nullptr) { return BQ::ERR_MALLOC; }
    ON_SCOPE_EXIT([&]() { if (decrypted_key) free(decrypted_key); decrypted_key = nullptr; });
    memset(decrypted_key, 0, encrypted_key_size);
    int nret = decrypt_aes(mode, key, key_size * 8, hash_k.bytes(), blocksize, encrypted_key, encrypted_key_size, decrypted_key);
    if (BQ::OK != nret) {
        return nret;
    }

    uint8_t* decrypted_val = (uint8_t*)malloc(encrypted_val_size);
    if (decrypted_val == nullptr) { return BQ::ERR_MALLOC; }
    ON_SCOPE_EXIT([&]() { if (decrypted_val) free(decrypted_val); decrypted_val = nullptr; });
    memset(decrypted_val, 0, encrypted_val_size);
    nret = decrypt_aes(mode, key, key_size * 8, hash_v.bytes(), blocksize, encrypted_val, encrypted_val_size, decrypted_val);
    if (BQ::OK != nret) {
        return nret;
    }

    // TODO:

    return BQ::NOT_IMPLEMENT;
}

int ecma376_agile_encryption_key(encryption_info_agile_t* encrypt, const char16_t* passwd, uint8_t* out, uint32_t& out_size) {
    if (encrypt == nullptr || out == nullptr || 0 == out_size) {
        return BQ::INVALID_ARG;
    }
    assert(strlen(encrypt->encryptor.cipher_algor) != 0);

    auto salt = encrypt->encryptor.salt;
    auto salt_size = encrypt->encryptor.saltsize;
    auto& encryptor = encrypt->encryptor;
    if (salt == nullptr || encryptor.cipher_chain == nullptr) {
        return BQ::INVALID_ARG;
    }

    const char* mode = nullptr;
    if (0 == strcmp(encrypt->encryptor.cipher_chain, "ChainingModeCFB")) {
        mode = "cfb"; // Cipher feedback chaining(CFB), with an 8-bit window
    }
    else if (0 == strcmp(encrypt->encryptor.cipher_chain, "ChainingModeCBC")) {
        mode = "cbc";
    }

    const uint8_t blockey_key[] = { 0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6 };
    uint8_t hash[AGILE_CB_HASH_MAX] = { 0 };

    uint32_t hash_size = sizeof(hash);
    int nret = ecma376_agile_encryption_key__iteration(encrypt, passwd, hash, hash_size);
    if (BQ::OK != nret) {
        return nret;
    }

    nret = ecma376_agile_encryption_key__final(encrypt, blockey_key, sizeof(blockey_key), hash, hash_size);
    if (BQ::OK != nret) {
        return nret;
    }

    auto encrypted_keyval_b64 = (const char*)encryptor.encrypted_keyval;
    uint32_t encrypted_keyval_size = 0;
    uint8_t* encrypted_keyval = base64_decode((const unsigned char*)encrypted_keyval_b64, strlen(encrypted_keyval_b64), (size_t*)&encrypted_keyval_size);
    ON_SCOPE_EXIT([&]() { if (encrypted_keyval) free(encrypted_keyval); encrypted_keyval = nullptr; });

    if (out_size >= encrypted_keyval_size) {
        memset(out, 0, out_size);
        nret = decrypt_aes(mode, hash, hash_size * 8, salt, salt_size, encrypted_keyval, encrypted_keyval_size, out);
    }
    else {
        nret = BQ::INVALID_ARG;
    }
    out_size = encrypted_keyval_size;

    return nret;
}

int ecma376_agile_passwd_verify(encryption_info_agile_t* encrypt, const char16_t* passwd) {
    if (encrypt == nullptr || nullptr == encrypt->encryptor.cipher_algor) {
        return BQ::INVALID_ARG;
    }
    assert(strlen(encrypt->encryptor.cipher_algor) != 0);
    
    auto salt = encrypt->encryptor.salt;
    auto salt_size = encrypt->encryptor.saltsize;
    auto& encryptor = encrypt->encryptor;
    if (salt == nullptr || encryptor.cipher_chain == nullptr || encryptor.encrypted_verifier_hash_input == nullptr || encryptor.encrypted_verifier_hash_value == nullptr) {
        return BQ::INVALID_ARG;
    }

    const char* mode = nullptr;
    if (0 == strcmp(encrypt->encryptor.cipher_chain, "ChainingModeCFB")) {
        mode = "cfb"; // Cipher feedback chaining(CFB), with an 8-bit window
    }
    else if (0 == strcmp(encrypt->encryptor.cipher_chain, "ChainingModeCBC")) {
        mode = "cbc";
    }

    if (0 != ucs::nicmp(encrypt->encryptor.cipher_algor, "aes", 3)) {
        return BQ::NOT_IMPLEMENT;
    }

    const uint8_t blockey_input[] = { 0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79 };
    const uint8_t blockey_value[] = { 0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e };

    uint8_t hash[AGILE_CB_HASH_MAX] = { 0 };
    uint8_t input_key[AGILE_CB_HASH_MAX] = { 0 };
    uint8_t value_key[AGILE_CB_HASH_MAX] = { 0 };

    uint32_t hash_size = sizeof(hash);
    int nret = ecma376_agile_encryption_key__iteration(encrypt, passwd, hash, hash_size);
    if (BQ::OK != nret) {
        return nret;
    }
    memcpy(input_key, hash, hash_size);
    memcpy(value_key, hash, hash_size);
    
    uint32_t input_key_size = hash_size;
    nret = ecma376_agile_encryption_key__final(encrypt, blockey_input, sizeof(blockey_input), input_key, input_key_size);
    if (BQ::OK != nret) {
        return nret;
    }

    uint32_t value_key_size = hash_size;    
    nret = ecma376_agile_encryption_key__final(encrypt, blockey_value, sizeof(blockey_value), value_key, value_key_size);
    if (BQ::OK != nret) {
        return nret;
    }

    auto encrypted_input_b64 = (const char*)encryptor.encrypted_verifier_hash_input;
    uint32_t encrypted_input_size = 0;
    uint8_t* encrypted_input = base64_decode((const unsigned char*)encrypted_input_b64, strlen(encrypted_input_b64), (size_t*)&encrypted_input_size);
    ON_SCOPE_EXIT([&]() { if (encrypted_input) free(encrypted_input); encrypted_input = nullptr; });

    auto encrypted_value_b64 = (const char*)encryptor.encrypted_verifier_hash_value;
    uint32_t encrypted_value_size = 0;
    uint8_t* encrypted_value = base64_decode((const unsigned char*)encrypted_value_b64, strlen(encrypted_value_b64), (size_t*)&encrypted_value_size);
    ON_SCOPE_EXIT([&]() { if (encrypted_value) free(encrypted_value); encrypted_value = nullptr; });

    uint8_t* decrypted_input = (uint8_t*)malloc(encrypted_input_size);
    if (decrypted_input == nullptr) { return BQ::ERR_MALLOC; }
    ON_SCOPE_EXIT([&]() { if (decrypted_input) free(decrypted_input); decrypted_input = nullptr; });
    memset(decrypted_input, 0, encrypted_input_size);
    nret = decrypt_aes(mode, input_key, input_key_size * 8, salt, salt_size, encrypted_input, encrypted_input_size, decrypted_input);
    if (BQ::OK != nret) {
        return nret;
    }

    Hash hfinal(encrypt->encryptor.hash_algor);
    memcpy(hash, hfinal.add(decrypted_input, encrypted_input_size).finalize().bytes(), hash_size);

    uint8_t* decrypted_value = (uint8_t*)malloc(encrypted_value_size);
    if (decrypted_value == nullptr) { return BQ::ERR_MALLOC; }
    ON_SCOPE_EXIT([&]() { if (decrypted_value) free(decrypted_value); decrypted_value = nullptr; });
    memset(decrypted_value, 0, encrypted_value_size);
    nret = decrypt_aes(mode, value_key, value_key_size * 8, salt, salt_size, encrypted_value, encrypted_value_size, decrypted_value);
    if (BQ::OK != nret) {
        return nret;
    }
    
    if (decrypted_value && 0 == memcmp(decrypted_value, hash, hash_size)) {
        nret = BQ::OK;
    }
    else {
        nret = BQ::ERR_PASSWD; 
    }

    return nret;
}

int ecma376_agile_decrypt(encryption_info_agile_t* encrypt, const char16_t* passwd, uint8_t* data, uint32_t size, ifile* out, bool verify_integrity=false) {
    const uint32_t stream_size_bytes = 8;
    if (encrypt == nullptr || data == nullptr || size < stream_size_bytes || nullptr == out || encrypt->keydata.cipher_algor == nullptr) {
        return BQ::INVALID_ARG;
    }

    uint8_t key[AGILE_CB_HASH_MAX] = { 0 };
    uint32_t key_size = sizeof(key);
    int nret = ecma376_agile_encryption_key(encrypt, passwd, key, key_size);
    if (BQ::OK != nret) {
        return nret;
    }

    if (verify_integrity) {
        int nret = ecma376_agile_integrity_verify(encrypt, data, size, key, key_size);
        if (BQ::OK != nret) {
            return nret;
        }
    }

    const uint32_t segment_size = 4096;
    auto salt = encrypt->keydata.salt;
    auto salt_size = encrypt->keydata.saltsize;
    auto hash_algo = encrypt->keydata.hash_algor;
    auto blocksize = encrypt->keydata.blocksize;
    const char* mode = nullptr;
    if (0 == strcmp(encrypt->keydata.cipher_chain, "ChainingModeCFB")) {
        mode = "cfb"; // Cipher feedback chaining(CFB), with an 8-bit window
    }
    else if (0 == strcmp(encrypt->keydata.cipher_chain, "ChainingModeCBC")) {
        mode = "cbc";
    }

    if (0 != ucs::nicmp(encrypt->keydata.cipher_algor, "aes", 3) || blocksize != 0x10) {
        return BQ::NOT_IMPLEMENT;
    }

    data += stream_size_bytes;
    size -= stream_size_bytes;
    for (uint32_t i = 0; i * segment_size < size; i++) {
        Hash h(hash_algo);
        h.add(salt, salt_size).add((const uint8_t*)&i, sizeof(i)).finalize();

        auto buffer_size = std::min(size - i * segment_size, segment_size);
        nret = decrypt_aes(mode, key, key_size * 8, h.bytes(), blocksize, data + i * segment_size, buffer_size, 0, out, i * segment_size);
        if (BQ::OK != nret) {
            break;
        }
    }

    return nret;
}

int crypto_ecma376::passwd_verify(encryption_info_t* encrypt, const char16_t* passwd) {
    int nret = BQ::OK;

    int encryption_type = encrypt->type();
    switch (encryption_type) {
        case encryinfo_ecma376_extensible: {
            auto extensible = (encryption_info_ext_t*)encrypt;
            assert(extensible->header.external() == true);
            assert(extensible->header.algid_hash == 0);
            nret = BQ::NOT_IMPLEMENT;
            break;
        }
        case encryinfo_ecma376_std: {
            auto standard = (encryption_info_std_t*)encrypt;
            if (!standard->header.cryptoapi()) {
                // something unexpected
                nret = BQ::ERR_OFFICE_CRYPT_INFO;
            }
            else {
                nret = ecma376_std_passwd_verify(standard, passwd);
            }

            break;
        }
        case encryinfo_ecma376_agile: {
            nret = ecma376_agile_passwd_verify(&encrypt->agile, passwd);
            break;
        }
        default:
            break;
    }

    return nret;
}

int crypto_ecma376::decrypt(encryption_info_t* encrypt, const char16_t* passwd, uint8_t* data, uint32_t size, ifile* out) {
    int nret = BQ::OK;
    
    int encryption_type = encrypt->type();
    switch (encryption_type) {
        case encryinfo_ecma376_extensible: {
            auto extensible = (encryption_info_ext_t*)encrypt;
            assert(extensible->header.external() == true);
            assert(extensible->header.algid_hash == 0);
            nret = BQ::NOT_IMPLEMENT;
            break;
        }
        case encryinfo_ecma376_std: {
            auto standard = &encrypt->std;
            if (!standard->header.cryptoapi()) {
                // something unexpected
                nret = BQ::ERR_OFFICE_CRYPT_INFO;
            }
            else {
                nret = ecma376_std_decrypt(standard, passwd, data, size, out);
            }

            break;
        }
        case encryinfo_ecma376_agile: {
            bool verify_integrity = false;
            nret = ecma376_agile_decrypt(&encrypt->agile, passwd, data, size, out, verify_integrity);

            break;
        }
        default:
            break;
    }

    return nret;
}
